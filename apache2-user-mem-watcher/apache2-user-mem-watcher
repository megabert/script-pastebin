#!/usr/bin/env php
<?PHP

function mylog($text) {
        print(date("r")." $text\n");
}

function get_mem_info() {

        $ps = shell_exec("/bin/ps axu");
        $meminfo = [];
        $pidinfo = [];
        $mem_usage=0;
        foreach(preg_split("/((\r?\n)|(\r\n?))/", $ps) as $line){
                if(preg_match("/^(web[0-9]+)\s+(\S+)\s+\S+\s+\S+\s+\S+\s+(\S+)/",$line,$matches)) {
                        if(!array_key_exists($matches[1],$meminfo)) {
                                $meminfo[$matches[1]]=0;
                        }
                        $pidinfo[$matches[2]]=[ "user" => $matches[1], "mem_used" => $matches[3]];
                        $meminfo[$matches[1]]=$matches[3]+$meminfo[$matches[1]];
                        $mem_usage=$mem_usage+$matches[3];
                } 
        }
        return [ $meminfo , $mem_usage, $pidinfo ];
}

function get_over_mem_users($meminfo,$max_mem) {

        $over_users = [];
        $over_user_count=0;
        foreach($meminfo as $user => $mem_usage_kb) {
                if($mem_usage_kb > $max_mem) {
                        $over_user_count++;
                        if($over_user_count==1) {
                                print("\n");
                        }
                        mylog("user $user consumes to much memory($mem_usage_kb)");
                        $over_users[$user]=$mem_usage_kb;
                }
        }
        return $over_users;

}

function kill_procs($over_users,$pidinfo) {
        if(count($over_users) == 0) {
                return;
        }
        $signal_list=[15,0,2,0,9];
        foreach($signal_list as $signal) {
                $alive_processes=0;
		#traverse all relevant pids
                foreach($pidinfo as $pid => $data) {
                        # check if the pid is owned by an over_user
                        if(array_key_exists($data["user"],$over_users)) {
                                # check if the process is still alive
                                if(process_is_alive($pid)) {
					$alive_processes++;
					# only send signal if != 0 (0 => placeholder for waiting time)
					if($signal != 0) {
						mylog("sending signal $signal to process $pid (pid is owned by ".$pidinfo[$pid]["user"]. " and uses ".$pidinfo[$pid]["mem_used"]." KB of memory)");
						posix_kill($pid,$signal);
					}
                                }
                        }
                }
                if($alive_processes==0) {
                        return;
                }
        	sleep(10);
        }
}

function process_is_alive($pid) {
		# kill with 0 does not send a signal, but only returns success if the process with the specified pid exists
                return posix_kill($pid,0);
}

function main($max_mem_per_user) {

        list($meminfo,$mem_usage_old,$pidinfo)  = get_mem_info();
        $over_users                             = get_over_mem_users($meminfo,$max_mem_per_user);
        kill_procs($over_users,$pidinfo);
        list($meminfo,$mem_usage_new,$pidinfo)  = get_mem_info();
        return [ $mem_usage_old, $mem_usage_new ];
}

## main program starts here

$max_mem_per_user="1000000";  // -> 1 GB

# only run 1000 times; avoid php memory leaks
# # with 10 seconds pause this script runs for ~ 3 hours with a single run

for($counter=1;$counter<1000;$counter++) {
        print(".");
        #print(date("r")." checking webhosting memory usage\n");
        list($mem_old,$mem_new) = main($max_mem_per_user);
        #print(date("r")." customers used $mem_old KB before check and $mem_new KB now\n");
        sleep(10);
}

?>
